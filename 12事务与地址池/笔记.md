#事务&数据库连接池&DBUtils

##事务
	
	Transaction 其实指的一组操作，里面包含许多单一的逻辑，只要有一个逻辑没有执行成功，那
么都算失败，所有的数据都回归到最初的状态（回滚）


###使用命令行方式演示事务

*开启事务
	start transaction；
	
*提交或者回滚事务
	commit:	提交事务，数据将会写到磁盘上的数据库
	rollback：数据回滚，回到最初的状态



1、数据库关闭自动提交功能
	set autocommit = off;（查看语句 show variables like'%commit%;
	rollback 回滚
	commit   提交
	
	
###代码演示
	代码里面的事务，主要是针对连接来的，通过conn.setAutoCommit(false)来关闭事务自动提交
	
	
###事务的特性
	原子性
	》指的是 事务中包含的逻辑，不可分割
	一致性
	》指的是 事务执行后，数据完整性
	隔离性
	》指的是 事务在执行期间不应该受到其他事务的影响
	持久性
	》指的是 事务执行成功，那么数据应该持久保存在磁盘上
	
###事务的安全隐患
	不考虑级别设置，那么会出现以下问题
	
	*读
		》脏读，不可重复读：一个事务读到另外一个事务提交的数据，造成前后两次查询结果不一致，
			>一个事务读到另外一个事务还未提交的数据
				设置A窗口的隔离级别为‘读未提交’
					select @@tx_isolation 查看状态
					set session transaction； isolation level read uncommitted;
					
					
				设置A窗口的隔离级别为'读已提交‘
				A B 两个窗口都开启事务，在B窗口执行更新操作
				
				设置A窗口的隔离级别为'可重复读‘
				set session transaction； isolation level repeatable read;
		
				设置A窗口的隔离级别为'可串行化‘
				serializable
					
		》幻读
			一个事务读到另外一个事务已提交的插入数据，导致多次查询结果不一致
					
	
	
	*写
	
	
	
*按效率划分，从高到低
	读未提交 > 读已提交 > 可重复读 > 可串行化

*按拦截程度，从低到高
	读未提交 > 读已提交 > 可重复读 > 可串行化
	
	
###丢失更新
	A B事务都查询出lisi 1000
	先A更新名字后B更新钱800
	会造成数据丢失最后会显示 lisi 800
	
	B事务如果提交，那么会造成修改的名字没有了
	B事务回滚，那么也会造成A事务更新没有了
	
	*悲观锁（假设丢失更新一定发生）
		select * from account for update;(数据库锁机制，排他锁)相当于可串行化
	
	
	*乐观锁（假设丢失更新一定不会发生）
		要求程序员自己控制
	
	
###数据库连接池
	》1、数据库的连接对象工作，比较消耗性能
	》2、一开始先在内存中开辟一块空间（集合），先往池子里面
		放置多个连接对象，后面需要连接的话，直接从池子里面去，
		不要自己去创建连接，使用完毕，要记得归还连接。
		确保连接对象能循环利用。
		
		
###自定义数据库连接池
*出现的问题
	1、需要额外记住addBack方法
	2、单例
	3、无法面向接口编程
	4、怎么解决？以addBack为切入点
	
	
###开源连接池
	
	*DBCP
		配置文件实现
			BasicDataSourceFactory factory = new BasicDataSourceFactory();
			Propertied ps = new Propertied();
			InputStream is = new FileInputStream("配置文件位置");
			ps.load(is);
			DataSource dataSource = factory.createDataSource(ps);
			
			
	
	*C3P0
	
	
	
	
	
	
	
	
	
	
	
	
